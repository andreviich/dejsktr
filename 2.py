# -*- coding: utf-8 -*-
"""BnB.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nAlJgSYLskBpSHD4eDmySKbfWLZljIbM
"""

import csv
import random
variant = int(input('Введите формат вводимых данных матрицы:\n1) ввод с клавитуры\n2)случайная генерация\n3)считывание из CSV  файла'))
try:
    vs = int(input("Введите количество вершин... "))

    matrix = []

    if variant == 1:

        for i in range(vs):
            st = input(f"Введите {i+1} строку матрицы через пробел... ")

            st = [int(i) for i in st.split()]

            if len(st) != vs:
                raise Exception
            else:
                matrix.append(st)
    elif variant == 2:
        for i in range(vs): matrix.append([random.randint(1,10) for i in range(vs)])

    elif variant == 3:
        with open('data.csv', encoding="utf-8-sig", mode="r") as csvfile:
            spamreader = csv.reader(csvfile, delimiter=';')
            for row in spamreader:
                matrix.append([int(i) for i in row])
except Exception as e:
    print(e)
number = vs

# МЕТОД ВЕТВЕЙ И ГРАНИЦ
import math
import time
def branch_and_bound(size, matr):
    maxsize = float('inf')
    global final_res, final_path

    # Function to copy temporary solution
    # to the final solution
    def copyToFinal(curr_path):
        final_path[:N + 1] = curr_path[:]
        final_path[N] = curr_path[0]
        

    # Function to find the minimum edge cost
    # having an end at the vertex i
    def firstMin(adj, i):
        min = maxsize
        for k in range(N):
            if adj[i][k] < min and i != k:
                min = adj[i][k]
                

        return min

    # function to find the second minimum edge
    # cost having an end at the vertex i
    def secondMin(adj, i):
        first, second = maxsize, maxsize
        for j in range(N):
            if i == j:
                continue
            if adj[i][j] <= first:
                second = first
                first = adj[i][j]

            elif (adj[i][j] <= second and adj[i][j] != first):
                second = adj[i][j]
                

        return second

    # function that takes as arguments:
    # curr_bound -> lower bound of the root node
    # curr_weight-> stores the weight of the path so far
    # level-> current level while moving
    # in the search space tree
    # curr_path[] -> where the solution is being stored
    # which would later be copied to final_path[]
    def TSPRec(adj, curr_bound, curr_weight, level, curr_path, visited):
        global final_res
        # base case is when we have reached level N
        # which means we have covered all the nodes once
        if level == N:
            # check if there is an edge from
            # last vertex in path back to the first vertex
            if adj[curr_path[level - 1]][curr_path[0]] != 0:
                curr_res = curr_weight + adj[curr_path[level - 1]]\
                                        [curr_path[0]]
                if curr_res < final_res:
                    copyToFinal(curr_path)
                    final_res = curr_res
            
            return

        # for any other level iterate for all vertices
        # to build the search space tree recursively
        for i in range(N):

            # Consider next vertex if it is not same
            # (diagonal entry in adjacency matrix and
            # not visited already)
            if (adj[curr_path[level - 1]][i] != 0 and
                    visited[i] == False):
                temp = curr_bound
                curr_weight += adj[curr_path[level - 1]][i]
            

                # different computation of curr_bound
                # for level 2 from the other levels
                if level == 1:
                    curr_bound -= ((firstMin(adj, curr_path[level - 1]) +
                                    firstMin(adj, i)) / 2)
                    
                else:
                    curr_bound -= ((secondMin(adj, curr_path[level - 1]) +
                                    firstMin(adj, i)) / 2)

                # curr_bound + curr_weight is the actual lower bound
                # for the node that we have arrived on.
                # If current lower bound < final_res,
                # we need to explore the node further
                if curr_bound + curr_weight < final_res:
                    curr_path[level] = i
                    visited[i] = True

                    # call TSPRec for the next level
                    TSPRec(adj, curr_bound, curr_weight,
                           level + 1, curr_path, visited)

                # Else we have to prune the node by resetting
                # all changes to curr_weight and curr_bound Печатать матр на входе / 
                curr_weight -= adj[curr_path[level - 1]][i]
                curr_bound = temp

                # Also reset the visited array
                visited = [False] * len(visited)
                for j in range(level):
                    if curr_path[j] != -1:
                        visited[curr_path[j]] = True

    # This function sets up final_path
    def TSP(adj):
        # Calculate initial lower bound for the root node
        # using the formula 1/2 * (sum of first min +
        # second min) for all edges. Also initialize the
        # curr_path and visited array
        curr_bound = 0
        curr_path = [-1] * (N + 1)
        visited = [False] * N

        # Compute initial bound
        for i in range(N):
            curr_bound += (firstMin(adj, i) +
                           secondMin(adj, i))

        # Rounding off the lower bound to an integer
        curr_bound = math.ceil(curr_bound / 2)

        # We start at vertex 1 so the first vertex
        # in curr_path[] is 0
        visited[0] = True
        curr_path[0] = 0

        # Call to TSPRec for curr_weight
        # equal to 0 and level 1
        TSPRec(adj, curr_bound, 0, 1, curr_path, visited)

    # Driver code

    # Adjacency matrix for the given graph
    adj = matr
    N = size

    # final_path[] stores the final solution
    # i.e. the // path of the salesman.
    final_path = [None] * (N + 1)

    # visited[] keeps track of the already
    # visited nodes in a particular path
    visited = [False] * N

    # Stores the final minimum weight
    # of shortest tour.
    final_res = maxsize

    TSP(adj)
itter = []
itog = []
num = 1
print("Первоначальная матрица: \n", matrix)
print("--------------------------------------------------")
start_time = time.time()
branch_and_bound(number, matrix)
print("Алгоритм: Метод ветвей и границ")
print("Время работы ", "%.20f" % (time.time() - start_time))
print("Полученный путь : ", [x + 1 for x in final_path])
print("Стоимость :", final_res)
